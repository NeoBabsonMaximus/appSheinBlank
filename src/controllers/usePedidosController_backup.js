// Pedidos Controller - Business Logic for Orders Management
import { useState, useEffect, useRef } from 'react';
import { 
  subscribeToPedidos, 
  addDocument, 
  updateDocument, 
  deleteDocument
} from '../models/pedidosModel';
import {
  collection,
  getDocs,
  query,
  where
} from 'firebase/firestore';
import { getClientByPhoneNumber, addCliente, updateCliente } from '../models/clientesModel';
import { addTransaccion } from '../models/transaccionesModel';
import { generateUniqueToken } from '../utils/formatters';

export const usePedidosController = (db, userId, appId) => {
  const [pedidos, setPedidos] = useState([]);
  const [currentPedido, setCurrentPedido] = useState({
    nombreCliente: '',
    numeroTelefono: '',
    productos: [],
    precioTotal: 0,
    estado: 'pendiente',
    fechaEstimadaLlegada: '',
    numeroRastreo: '',
    saldoPendiente: 0,
    pagado: false,
    numeroPedido: '',
  });
  const [editingId, setEditingId] = useState(null);
  const isLocallyEditingRef = useRef(false);
  const lastSaveTimeRef = useRef(0);
  const isSavingRef = useRef(false);

  useEffect(() => {
    if (!db || !userId) {
      return;
    }

    const unsubscribe = subscribeToPedidos(db, userId, appId, (pedidosData) => {
      console.log("üì• Datos recibidos de Firestore:", pedidosData.length, "pedidos");
      console.log("üîí IsLocallyEditing:", isLocallyEditingRef.current);
      console.log("üÜî EditingId actual:", editingId);
      
      // Siempre actualizar la lista de pedidos
      setPedidos(pedidosData);
      
      // Si estamos editando un pedido, actualizar tambi√©n el currentPedido con los datos m√°s recientes
      if (editingId && !isLocallyEditingRef.current) {
        const updatedPedido = pedidosData.find(p => p.id === editingId);
        if (updatedPedido) {
          console.log("üîÑ Actualizando currentPedido con datos de Firestore");
          setCurrentPedido({
            ...updatedPedido,
            productos: updatedPedido.productos || [],
            fechaEstimadaLlegada: updatedPedido.fechaEstimadaLlegada ? 
              new Date(updatedPedido.fechaEstimadaLlegada).toISOString().split('T')[0] : '',
          });
        }
      } else if (isLocallyEditingRef.current) {
        console.log("‚è∏Ô∏è Pausando actualizaci√≥n de currentPedido - editando localmente");
      } else {
        console.log("‚úÖ Actualizando solo lista de pedidos");
      }
    });
    
    return () => {
      if (unsubscribe) unsubscribe();
    };
  }, [db, userId, appId, editingId]);

  const calculateTotals = (products) => {
    const total = products.reduce((sum, item) => sum + item.subtotal, 0);
    return {
      totalPrice: total,
      newSaldoPendiente: total,
    };
  };

  const addProductToCurrentPedido = (newProduct) => {
    console.log("‚ûï Agregando producto:", newProduct);
    console.log("üìù Productos antes de agregar:", currentPedido.productos);
    isLocallyEditingRef.current = true;
    
    // Agregar campo de completado al nuevo producto
    const productWithCompletion = {
      ...newProduct,
      completed: false // Campo simple para marcar como completado
    };
    
    const updatedProducts = [...currentPedido.productos, productWithCompletion];
    const { totalPrice, newSaldoPendiente } = calculateTotals(updatedProducts);
    console.log("üìù Productos despu√©s de agregar:", updatedProducts);
    setCurrentPedido({
      ...currentPedido,
      productos: updatedProducts,
      precioTotal: totalPrice,
      saldoPendiente: newSaldoPendiente,
    });
    
    // NO resetear el flag aqu√≠ - se resetear√° despu√©s del guardado autom√°tico
  };

  const removeProductFromCurrentPedido = (indexToRemove) => {
    console.log("üóëÔ∏è Eliminando producto en √≠ndice:", indexToRemove);
    console.log("üìù Productos antes de eliminar:", currentPedido.productos);
    console.log("üìù √çndice a eliminar:", indexToRemove);
    
    // Activar modo de edici√≥n local
    isLocallyEditingRef.current = true;
    
    const updatedProducts = currentPedido.productos.filter((_, index) => {
      console.log(`Comparando √≠ndice ${index} con ${indexToRemove}: ${index !== indexToRemove ? 'MANTENER' : 'ELIMINAR'}`);
      return index !== indexToRemove;
    });
    console.log("üìù Productos despu√©s de eliminar:", updatedProducts);
    
    const { totalPrice, newSaldoPendiente } = calculateTotals(updatedProducts);
    setCurrentPedido({
      ...currentPedido,
      productos: updatedProducts,
      precioTotal: totalPrice,
      saldoPendiente: newSaldoPendiente,
    });
    
    // NO resetear el flag aqu√≠ - se resetear√° despu√©s del guardado autom√°tico
  };

  const editProductInCurrentPedido = (indexToEdit, updatedProduct) => {
    isLocallyEditingRef.current = true;
    const updatedProducts = [...currentPedido.productos];
    updatedProducts[indexToEdit] = updatedProduct;
    const { totalPrice, newSaldoPendiente } = calculateTotals(updatedProducts);
    setCurrentPedido({
      ...currentPedido,
      productos: updatedProducts,
      precioTotal: totalPrice,
      saldoPendiente: newSaldoPendiente,
    });
    
    // NO resetear el flag aqu√≠ - se resetear√° despu√©s del guardado autom√°tico
  };

  const toggleProductCompleted = (productIndex) => {
    console.log(`‚úÖ Cambiando estado de completado del producto ${productIndex}`);
    isLocallyEditingRef.current = true;
    
    const updatedProducts = [...currentPedido.productos];
    updatedProducts[productIndex] = {
      ...updatedProducts[productIndex],
      completed: !updatedProducts[productIndex].completed
    };
    
    setCurrentPedido({
      ...currentPedido,
      productos: updatedProducts,
    });
    
    // Guardar autom√°ticamente solo el cambio de producto, sin notificaci√≥n de estado
    setTimeout(() => {
      saveProductCompletionOnly(productIndex).catch(error => {
        console.error("Error al guardar cambio de completado:", error);
      });
    }, 100);
  };

  // Funci√≥n espec√≠fica para guardar solo cambios de productos sin notificaciones
  const saveProductCompletionOnly = async (productIndex) => {
    try {
      if (!editingId) {
        console.log("‚è≠Ô∏è No es una edici√≥n, saltando guardado autom√°tico de producto");
        return;
      }

      console.log(`üíæ Guardando solo cambio de completado del producto ${productIndex}`);
      
      // Limpiar n√∫mero de tel√©fono
      let cleanPhoneNumber = currentPedido.numeroTelefono.toString().replace(/\D/g, '');
      if (cleanPhoneNumber.length === 12 && cleanPhoneNumber.startsWith('52')) {
        cleanPhoneNumber = cleanPhoneNumber.substring(2);
      }

      const dataToSave = {
        ...currentPedido,
        numeroTelefono: cleanPhoneNumber,
        pagado: currentPedido.saldoPendiente <= 0.01,
      };

      await updateDocument(db, userId, appId, 'pedidos', editingId, dataToSave);
      
      console.log("‚úÖ Producto actualizado sin enviar notificaci√≥n");
      
      setTimeout(() => {
        console.log("üîì Reseteando isLocallyEditing despu√©s de guardar producto");
        isLocallyEditingRef.current = false;
      }, 500);
      
    } catch (error) {
      console.error("‚ùå Error guardando cambio de producto:", error);
      isLocallyEditingRef.current = false;
    }
  };

  const savePedido = async () => {
    // Prevenir guardados m√∫ltiples simult√°neos
    if (isSavingRef.current) {
      console.log("‚è∏Ô∏è Ya se est√° guardando, saltando duplicado");
      return;
    }

    const now = Date.now();
    // Prevenir guardados muy frecuentes (menos de 1 segundo)
    if (now - lastSaveTimeRef.current < 1000) {
      console.log("‚è∏Ô∏è Guardado muy reciente, saltando para evitar spam");
      return;
    }

    isSavingRef.current = true;
    lastSaveTimeRef.current = now;

    try {
      if (currentPedido.productos.length === 0) {
        throw new Error("No se puede guardar un pedido sin productos.");
      }

      console.log("üíæ Iniciando guardado de pedido...");

      // Obtener los datos anteriores del pedido si estamos editando
      let previousOrderData = null;
      if (editingId) {
        const existingOrder = pedidos.find(p => p.id === editingId);
        previousOrderData = {
          estado: existingOrder?.estado,
          fechaEstimadaLlegada: existingOrder?.fechaEstimadaLlegada,
          numeroRastreo: existingOrder?.numeroRastreo
        };
        console.log(`üìä Datos anteriores:`, previousOrderData);
        console.log(`üìä Datos nuevos: estado=${currentPedido.estado}, fecha=${currentPedido.fechaEstimadaLlegada}, rastreo=${currentPedido.numeroRastreo}`);
      }

      // Limpiar n√∫mero de tel√©fono sin agregar c√≥digo de pa√≠s autom√°ticamente
      let cleanPhoneNumber = currentPedido.numeroTelefono.toString().replace(/\D/g, '');
      
      // Si tiene 12 d√≠gitos y empieza con 52, quitar el 52
      if (cleanPhoneNumber.length === 12 && cleanPhoneNumber.startsWith('52')) {
        cleanPhoneNumber = cleanPhoneNumber.substring(2);
      }
      
      // Si tiene prefijos mexicanos, quitarlos
      if (cleanPhoneNumber.startsWith('044') || cleanPhoneNumber.startsWith('045')) {
        cleanPhoneNumber = cleanPhoneNumber.substring(3);
      } else if (cleanPhoneNumber.startsWith('01')) {
        cleanPhoneNumber = cleanPhoneNumber.substring(2);
      }

      let clienteIdToUse = currentPedido.clienteId;
      if (currentPedido.nombreCliente && cleanPhoneNumber) {
        let existingClient = await getClientByPhoneNumber(db, userId, appId, cleanPhoneNumber);

        if (existingClient) {
          clienteIdToUse = existingClient.id;
          if (existingClient.nombre !== currentPedido.nombreCliente) {
            await updateCliente(db, userId, appId, existingClient.id, { nombre: currentPedido.nombreCliente });
          }
        } else {
          const newClientId = await addCliente(db, userId, appId, {
            nombre: currentPedido.nombreCliente,
            contacto: cleanPhoneNumber,
          });
          clienteIdToUse = newClientId;
        }
      }

      // Generar n√∫mero de pedido si no existe (solo para pedidos nuevos)
      let numeroPedido = currentPedido.numeroPedido;
      if (!editingId && !numeroPedido) {
        // Generar n√∫mero secuencial basado en la fecha y cantidad de pedidos
        const today = new Date();
        const datePrefix = today.getFullYear().toString().slice(-2) + 
                          (today.getMonth() + 1).toString().padStart(2, '0') + 
                          today.getDate().toString().padStart(2, '0');
        
        // Obtener el √∫ltimo n√∫mero de pedido del d√≠a para hacer el secuencial
        const todaysPedidos = pedidos.filter(p => {
          const pedidoDate = new Date(p.fechaCreacion);
          return pedidoDate.toDateString() === today.toDateString();
        });
        
        const nextSequence = (todaysPedidos.length + 1).toString().padStart(3, '0');
        numeroPedido = `#${datePrefix}${nextSequence}`;
        
        console.log(`üî¢ N√∫mero de pedido generado: ${numeroPedido}`);
      }

      const dataToSave = {
        ...currentPedido,
        clienteId: clienteIdToUse,
        numeroTelefono: cleanPhoneNumber,
        pagado: currentPedido.saldoPendiente <= 0.01,
        numeroPedido: numeroPedido,
      };

      if (editingId) {
        await updateDocument(db, userId, appId, 'pedidos', editingId, dataToSave);
        
        // Verificar qu√© cambios ocurrieron y crear notificaciones apropiadas
        const notifications = [];
        
        // 1. Cambio de estado
        if (previousOrderData.estado && previousOrderData.estado !== currentPedido.estado) {
          const pedidoRef = currentPedido.numeroPedido || `#${editingId.slice(-6)}`;
          notifications.push({
            tipo: 'pedido_actualizado',
            titulo: 'üì¶ Estado de tu pedido actualizado',
            mensaje: `Tu pedido ${pedidoRef} ha cambiado de "${previousOrderData.estado}" a "${currentPedido.estado}"`,
            fechaCreacion: new Date(),
            leido: false,
            prioridad: 'high',
            pedidoId: editingId,
            numeroTelefono: cleanPhoneNumber,
            estadoAnterior: previousOrderData.estado,
            estadoNuevo: currentPedido.estado,
            numeroPedido: currentPedido.numeroPedido
          });
          console.log(`üîî Estado cambi√≥: "${previousOrderData.estado}" ‚Üí "${currentPedido.estado}"`);
        }
        
        // 2. Cambio de fecha de llegada
        if (previousOrderData.fechaEstimadaLlegada !== currentPedido.fechaEstimadaLlegada && currentPedido.fechaEstimadaLlegada) {
          const fechaAnterior = previousOrderData.fechaEstimadaLlegada ? 
            new Date(previousOrderData.fechaEstimadaLlegada).toLocaleDateString('es-MX') : 'Sin fecha';
          const fechaNueva = new Date(currentPedido.fechaEstimadaLlegada).toLocaleDateString('es-MX');
          const pedidoRef = currentPedido.numeroPedido || `#${editingId.slice(-6)}`;
          
          notifications.push({
            tipo: 'fecha_actualizada',
            titulo: 'üìÖ Fecha de llegada actualizada',
            mensaje: `La fecha estimada de llegada de tu pedido ${pedidoRef} se actualiz√≥ a: ${fechaNueva}`,
            fechaCreacion: new Date(),
            leido: false,
            prioridad: 'medium',
            pedidoId: editingId,
            numeroTelefono: cleanPhoneNumber,
            fechaAnterior: fechaAnterior,
            fechaNueva: fechaNueva,
            numeroPedido: currentPedido.numeroPedido
          });
          console.log(`üîî Fecha cambi√≥: "${fechaAnterior}" ‚Üí "${fechaNueva}"`);
        }
        
        // 3. Cambio de n√∫mero de rastreo
        if (previousOrderData.numeroRastreo !== currentPedido.numeroRastreo && currentPedido.numeroRastreo) {
          const pedidoRef = currentPedido.numeroPedido || `#${editingId.slice(-6)}`;
          notifications.push({
            tipo: 'rastreo_actualizado',
            titulo: 'üöö N√∫mero de rastreo disponible',
            mensaje: `Tu pedido ${pedidoRef} ya tiene n√∫mero de rastreo: ${currentPedido.numeroRastreo}`,
            fechaCreacion: new Date(),
            leido: false,
            prioridad: 'medium',
            pedidoId: editingId,
            numeroTelefono: cleanPhoneNumber,
            numeroRastreo: currentPedido.numeroRastreo,
            numeroPedido: currentPedido.numeroPedido
          });
          console.log(`üîî N√∫mero de rastreo agregado: "${currentPedido.numeroRastreo}"`);
        }
        
        // Enviar todas las notificaciones
        for (const notificationData of notifications) {
          try {
            await addDocument(db, userId, appId, 'clientNotifications', notificationData);
            console.log(`‚úÖ Notificaci√≥n enviada: ${notificationData.titulo}`);
          } catch (notifError) {
            console.error('‚ùå Error enviando notificaci√≥n:', notifError);
          }
        }
        
        if (notifications.length === 0) {
          console.log(`‚è≠Ô∏è Sin cambios relevantes detectados - No se env√≠an notificaciones`);
        }
      } else {
        await addDocument(db, userId, appId, 'pedidos', dataToSave);
        console.log('üìù Nuevo pedido creado - No se env√≠a notificaci√≥n');
      }

      console.log("üíæ Guardado completado, esperando antes de resetear flag...");
      
      // Esperar un momento para que Firestore procese el cambio completamente
      setTimeout(() => {
        console.log("üîì Reseteando isLocallyEditing despu√©s de guardar exitosamente");
        isLocallyEditingRef.current = false;
        
        // Forzar una actualizaci√≥n inmediata si hay datos pendientes
        setTimeout(() => {
          console.log("üîÑ Verificando actualizaciones pendientes de Firestore...");
          // No hacer nada aqu√≠, solo esperar a que Firestore se sincronice
        }, 100);
      }, 500); // Tiempo m√°s largo para asegurar que Firestore procese
      
      // Solo resetear el pedido si NO estamos editando un pedido existente
      if (!editingId) {
        resetCurrentPedido(false); // No resetear el flag aqu√≠, se hace en el setTimeout
      }
      
      return true;
    } catch (error) {
      console.error("Error al guardar pedido:", error);
      // En caso de error, resetear el flag tambi√©n
      isLocallyEditingRef.current = false;
      throw error;
    } finally {
      // Siempre resetear el flag de saving
      isSavingRef.current = false;
    }
  };

  const deletePedido = async (id) => {
    try {
      await deleteDocument(db, userId, appId, 'pedidos', id);
      
      // Also delete from shared orders if exists
      const q = query(
        collection(db, `artifacts/${appId}/public/data/sharedPedidos`),
        where('originalPedidoId', '==', id)
      );
      const querySnapshot = await getDocs(q);
      querySnapshot.forEach(async (doc) => {
        await deleteDocument(db, userId, appId, 'sharedPedidos', doc.id, true);
      });
    } catch (error) {
      console.error("Error al eliminar pedido:", error);
      throw error;
    }
  };

  const archivePedido = async (pedidoId) => {
    try {
      // Find the order to validate
      const pedido = pedidos.find(p => p.id === pedidoId);
      
      if (pedido && pedido.saldoPendiente > 0) {
        throw new Error("No se puede archivar un pedido que tiene saldo pendiente");
      }
      
      await updateDocument(db, userId, appId, 'pedidos', pedidoId, { isArchived: true });
    } catch (error) {
      console.error("Error al archivar pedido:", error);
      throw error;
    }
  };

  const processPayment = async (pedido, amountToPay, isFullPayment = false) => {
    try {
      const finalAmount = isFullPayment ? pedido.saldoPendiente : amountToPay;
      
      if (finalAmount > pedido.saldoPendiente) {
        throw new Error(`El monto a pagar no puede ser mayor que el saldo pendiente.`);
      }

      const newSaldoPendiente = pedido.saldoPendiente - finalAmount;
      const newPagadoStatus = newSaldoPendiente <= 0.01;

      await updateDocument(db, userId, appId, 'pedidos', pedido.id, {
        saldoPendiente: newSaldoPendiente,
        pagado: newPagadoStatus,
      });

      await addTransaccion(db, userId, appId, {
        tipo: 'Ingreso',
        monto: finalAmount,
        descripcion: `Pago de pedido: ${pedido.nombreCliente} - ${pedido.productos.map(p => p.nombreProducto).join(', ')}`,
        fecha: new Date().toISOString().split('T')[0],
        pedidoId: pedido.id,
        clienteId: pedido.clienteId,
      });

      // Limpiar n√∫mero de tel√©fono para la notificaci√≥n
      let cleanPhoneNumber = pedido.numeroTelefono.toString().replace(/\D/g, '');
      if (cleanPhoneNumber.length === 12 && cleanPhoneNumber.startsWith('52')) {
        cleanPhoneNumber = cleanPhoneNumber.substring(2);
      }

      // Crear notificaci√≥n de pago
      try {
        const isPagoCompleto = newPagadoStatus;
        const montoFormateado = new Intl.NumberFormat('es-MX', { 
          style: 'currency', 
          currency: 'MXN' 
        }).format(finalAmount);
        
        const saldoRestanteFormateado = new Intl.NumberFormat('es-MX', { 
          style: 'currency', 
          currency: 'MXN' 
        }).format(newSaldoPendiente);

        const pedidoRef = pedido.numeroPedido || `#${pedido.id.slice(-6)}`;

        const notificationData = {
          tipo: isPagoCompleto ? 'pago_completo' : 'abono_registrado',
          titulo: isPagoCompleto ? 'üíö ¬°Pago completado!' : 'üí∞ Abono registrado',
          mensaje: isPagoCompleto ? 
            `¬°Gracias! Hemos recibido tu pago completo de ${montoFormateado} para el pedido ${pedidoRef}. Tu pedido est√° totalmente pagado.` :
            `Hemos recibido tu abono de ${montoFormateado} para el pedido ${pedidoRef}. Saldo restante: ${saldoRestanteFormateado}`,
          fechaCreacion: new Date(),
          leido: false,
          prioridad: 'high',
          pedidoId: pedido.id,
          numeroTelefono: cleanPhoneNumber,
          montoPagado: finalAmount,
          saldoRestante: newSaldoPendiente,
          pagoCompleto: isPagoCompleto,
          numeroPedido: pedido.numeroPedido
        };

        await addDocument(db, userId, appId, 'clientNotifications', notificationData);
        console.log(`‚úÖ Notificaci√≥n de pago enviada: ${isPagoCompleto ? 'Pago completo' : 'Abono'} - ${montoFormateado}`);
      } catch (notifError) {
        console.error('‚ùå Error enviando notificaci√≥n de pago:', notifError);
        // No fallar si la notificaci√≥n falla
      }

      return true;
    } catch (error) {
      console.error("Error al procesar el pago:", error);
      throw error;
    }
  };

  const generateShareLink = async (pedido) => {
    try {
      let token = pedido.shareableLinkToken;
      let sharedDocId = null;

      // Check if shared document already exists
      const q = query(
        collection(db, `artifacts/${appId}/public/data/sharedPedidos`),
        where('originalPedidoId', '==', pedido.id)
      );
      const querySnapshot = await getDocs(q);

      if (!querySnapshot.empty) {
        // Document exists, get token and document ID
        const existingDoc = querySnapshot.docs[0];
        token = existingDoc.data().shareableLinkToken;
        sharedDocId = existingDoc.id;
        
        // UPDATE the existing shared document with current pedido data
        await updateDocument(db, userId, appId, 'sharedPedidos', sharedDocId, {
          nombreCliente: pedido.nombreCliente,
          productos: pedido.productos,
          precioTotal: pedido.precioTotal,
          estado: pedido.estado,
          fechaEstimadaLlegada: pedido.fechaEstimadaLlegada,
          numeroRastreo: pedido.numeroRastreo,
          saldoPendiente: pedido.saldoPendiente,
          pagado: pedido.pagado,
          numeroPedido: pedido.numeroPedido,
        }, true);
        
        console.log("üîÑ Enlace compartido actualizado con datos m√°s recientes");
      } else {
        // Create new shared document
        token = generateUniqueToken();
        await addDocument(db, userId, appId, 'sharedPedidos', {
          originalPedidoId: pedido.id,
          shareableLinkToken: token,
          nombreCliente: pedido.nombreCliente,
          productos: pedido.productos,
          precioTotal: pedido.precioTotal,
          estado: pedido.estado,
          fechaEstimadaLlegada: pedido.fechaEstimadaLlegada,
          numeroRastreo: pedido.numeroRastreo,
          saldoPendiente: pedido.saldoPendiente,
          pagado: pedido.pagado,
          numeroPedido: pedido.numeroPedido,
        }, true);
        
        console.log("üÜï Nuevo enlace compartido creado");
      }

      if (pedido.shareableLinkToken !== token) {
        await updateDocument(db, userId, appId, 'pedidos', pedido.id, { shareableLinkToken: token });
      }

      // Use the deployed web URL instead of local origin for mobile compatibility
      const webUrl = 'https://appsheinblank.web.app';
      const shareLink = `${webUrl}/?view=share&token=${token}`;
      
      return shareLink;
    } catch (error) {
      console.error("Error al generar enlace compartible:", error);
      throw error;
    }
  };

  const resetCurrentPedido = (resetEditingFlag = true) => {
    setCurrentPedido({
      clienteId: '', nombreCliente: '', numeroTelefono: '', productos: [], precioTotal: 0, estado: 'Pendiente',
      fechaEstimadaLlegada: '', numeroRastreo: '', saldoPendiente: 0, pagado: false, isArchived: false, shareableLinkToken: '', numeroPedido: '',
    });
    setEditingId(null);
    
    // Solo resetear el flag si se especifica (para casos como cancelar edici√≥n)
    if (resetEditingFlag) {
      isLocallyEditingRef.current = false;
    }
  };

  const setCurrentPedidoForEdit = (pedido) => {
    // Asegurar que tomamos la versi√≥n m√°s reciente del pedido de la lista
    const latestPedido = pedidos.find(p => p.id === pedido.id) || pedido;
    
    console.log("üîß setCurrentPedidoForEdit llamado con pedido:", pedido.id);
    console.log("üìã Productos en pedido original:", pedido.productos?.length || 0);
    console.log("üìã Productos en pedido m√°s reciente:", latestPedido.productos?.length || 0);
    
    // Migrar productos existentes para que tengan campo completed
    const productosWithCompletion = (latestPedido.productos || []).map(producto => ({
      ...producto,
      completed: producto.completed || false
    }));
    
    setEditingId(latestPedido.id);
    isLocallyEditingRef.current = true; // Activar modo de edici√≥n local cuando se abre un pedido para editar
    setCurrentPedido({
      ...latestPedido,
      productos: productosWithCompletion,
      fechaEstimadaLlegada: latestPedido.fechaEstimadaLlegada ? 
        new Date(latestPedido.fechaEstimadaLlegada).toISOString().split('T')[0] : '',
    });
  };

  // Funci√≥n para calcular totales financieros
  const calculateFinancialTotals = () => {
    const activePedidos = pedidos.filter(pedido => !pedido.isArchived);
    
    const totalGeneral = activePedidos.reduce((sum, pedido) => sum + (pedido.precioTotal || 0), 0);
    const totalPendiente = activePedidos.reduce((sum, pedido) => sum + (pedido.saldoPendiente || 0), 0);
    const totalPagado = totalGeneral - totalPendiente;
    const porcentajePagado = totalGeneral > 0 ? (totalPagado / totalGeneral) * 100 : 0;
    
    return {
      totalGeneral,
      totalPagado,
      totalPendiente,
      porcentajePagado: Math.round(porcentajePagado)
    };
  };

  return {
    pedidos,
    currentPedido,
    setCurrentPedido,
    editingId,
    addProductToCurrentPedido,
    removeProductFromCurrentPedido,
    editProductInCurrentPedido,
    toggleProductCompleted,
    savePedido,
    deletePedido,
    archivePedido,
    processPayment,
    generateShareLink,
    resetCurrentPedido,
    setCurrentPedidoForEdit,
    calculateFinancialTotals,
  };
};
